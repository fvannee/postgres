--
-- SELECT_DISTINCT
--
--
-- awk '{print $3;}' onek.data | sort -n | uniq
--
SELECT DISTINCT two FROM tmp ORDER BY 1;
 two 
-----
   0
   1
(2 rows)

--
-- awk '{print $5;}' onek.data | sort -n | uniq
--
SELECT DISTINCT ten FROM tmp ORDER BY 1;
 ten 
-----
   0
   1
   2
   3
   4
   5
   6
   7
   8
   9
(10 rows)

--
-- awk '{print $16;}' onek.data | sort -d | uniq
--
SELECT DISTINCT string4 FROM tmp ORDER BY 1;
 string4 
---------
 AAAAxx
 HHHHxx
 OOOOxx
 VVVVxx
(4 rows)

--
-- awk '{print $3,$16,$5;}' onek.data | sort -d | uniq |
-- sort +0n -1 +1d -2 +2n -3
--
SELECT DISTINCT two, string4, ten
   FROM tmp
   ORDER BY two using <, string4 using <, ten using <;
 two | string4 | ten 
-----+---------+-----
   0 | AAAAxx  |   0
   0 | AAAAxx  |   2
   0 | AAAAxx  |   4
   0 | AAAAxx  |   6
   0 | AAAAxx  |   8
   0 | HHHHxx  |   0
   0 | HHHHxx  |   2
   0 | HHHHxx  |   4
   0 | HHHHxx  |   6
   0 | HHHHxx  |   8
   0 | OOOOxx  |   0
   0 | OOOOxx  |   2
   0 | OOOOxx  |   4
   0 | OOOOxx  |   6
   0 | OOOOxx  |   8
   0 | VVVVxx  |   0
   0 | VVVVxx  |   2
   0 | VVVVxx  |   4
   0 | VVVVxx  |   6
   0 | VVVVxx  |   8
   1 | AAAAxx  |   1
   1 | AAAAxx  |   3
   1 | AAAAxx  |   5
   1 | AAAAxx  |   7
   1 | AAAAxx  |   9
   1 | HHHHxx  |   1
   1 | HHHHxx  |   3
   1 | HHHHxx  |   5
   1 | HHHHxx  |   7
   1 | HHHHxx  |   9
   1 | OOOOxx  |   1
   1 | OOOOxx  |   3
   1 | OOOOxx  |   5
   1 | OOOOxx  |   7
   1 | OOOOxx  |   9
   1 | VVVVxx  |   1
   1 | VVVVxx  |   3
   1 | VVVVxx  |   5
   1 | VVVVxx  |   7
   1 | VVVVxx  |   9
(40 rows)

--
-- awk '{print $2;}' person.data |
-- awk '{if(NF!=1){print $2;}else{print;}}' - emp.data |
-- awk '{if(NF!=1){print $2;}else{print;}}' - student.data |
-- awk 'BEGIN{FS="      ";}{if(NF!=1){print $5;}else{print;}}' - stud_emp.data |
-- sort -n -r | uniq
--
SELECT DISTINCT p.age FROM person* p ORDER BY age using >;
 age 
-----
  98
  88
  78
  68
  60
  58
  50
  48
  40
  38
  34
  30
  28
  25
  24
  23
  20
  19
  18
   8
(20 rows)

--
-- Check mentioning same column more than once
--
EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(*) FROM
  (SELECT DISTINCT two, four, two FROM tenk1) ss;
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   Output: count(*)
   ->  HashAggregate
         Output: tenk1.two, tenk1.four, tenk1.two
         Group Key: tenk1.two, tenk1.four, tenk1.two
         ->  Seq Scan on public.tenk1
               Output: tenk1.two, tenk1.four, tenk1.two
(7 rows)

SELECT count(*) FROM
  (SELECT DISTINCT two, four, two FROM tenk1) ss;
 count 
-------
     4
(1 row)

--
-- Also, some tests of IS DISTINCT FROM, which doesn't quite deserve its
-- very own regression file.
--
CREATE TEMP TABLE disttable (f1 integer);
INSERT INTO DISTTABLE VALUES(1);
INSERT INTO DISTTABLE VALUES(2);
INSERT INTO DISTTABLE VALUES(3);
INSERT INTO DISTTABLE VALUES(NULL);
-- basic cases
SELECT f1, f1 IS DISTINCT FROM 2 as "not 2" FROM disttable;
 f1 | not 2 
----+-------
  1 | t
  2 | f
  3 | t
    | t
(4 rows)

SELECT f1, f1 IS DISTINCT FROM NULL as "not null" FROM disttable;
 f1 | not null 
----+----------
  1 | t
  2 | t
  3 | t
    | f
(4 rows)

SELECT f1, f1 IS DISTINCT FROM f1 as "false" FROM disttable;
 f1 | false 
----+-------
  1 | f
  2 | f
  3 | f
    | f
(4 rows)

SELECT f1, f1 IS DISTINCT FROM f1+1 as "not null" FROM disttable;
 f1 | not null 
----+----------
  1 | t
  2 | t
  3 | t
    | f
(4 rows)

-- check that optimizer constant-folds it properly
SELECT 1 IS DISTINCT FROM 2 as "yes";
 yes 
-----
 t
(1 row)

SELECT 2 IS DISTINCT FROM 2 as "no";
 no 
----
 f
(1 row)

SELECT 2 IS DISTINCT FROM null as "yes";
 yes 
-----
 t
(1 row)

SELECT null IS DISTINCT FROM null as "no";
 no 
----
 f
(1 row)

-- negated form
SELECT 1 IS NOT DISTINCT FROM 2 as "no";
 no 
----
 f
(1 row)

SELECT 2 IS NOT DISTINCT FROM 2 as "yes";
 yes 
-----
 t
(1 row)

SELECT 2 IS NOT DISTINCT FROM null as "no";
 no 
----
 f
(1 row)

SELECT null IS NOT DISTINCT FROM null as "yes";
 yes 
-----
 t
(1 row)

-- index only skip scan
SELECT DISTINCT four FROM tenk1;
 four 
------
    0
    1
    2
    3
(4 rows)

SELECT DISTINCT four FROM tenk1 WHERE four = 1;
 four 
------
    1
(1 row)

SELECT DISTINCT four FROM tenk1 ORDER BY four DESC;
 four 
------
    3
    2
    1
    0
(4 rows)

CREATE TABLE distinct_a (a int, b int, c int);
INSERT INTO distinct_a (
    SELECT five, hundred, 10 FROM
    generate_series(1, 5) five,
    generate_series(1, 100) hundred
);
CREATE INDEX ON distinct_a (a, b);
ANALYZE a;
-- test index skip scan with a condition on a non unique field
SELECT DISTINCT ON (a) a, b FROM distinct_a WHERE b = 2;
 a | b 
---+---
 1 | 2
 2 | 2
 3 | 2
 4 | 2
 5 | 2
(5 rows)

-- test index skip scan backwards
SELECT DISTINCT ON (a) a, b FROM distinct_a ORDER BY a DESC, b DESC;
 a |  b  
---+-----
 5 | 100
 4 | 100
 3 | 100
 2 | 100
 1 | 100
(5 rows)

DROP TABLE distinct_a;
-- index skip scan
SELECT DISTINCT ON (four) four, ten
FROM tenk1 ORDER BY four;
 four | ten 
------+-----
    0 |   0
    1 |   9
    2 |   0
    3 |   1
(4 rows)

SELECT DISTINCT ON (four) four, ten
FROM tenk1 WHERE four = 1 ORDER BY four;
 four | ten 
------+-----
    1 |   9
(1 row)

EXPLAIN (COSTS OFF)
SELECT DISTINCT ON (four) four, ten
FROM tenk1 ORDER BY four;
              QUERY PLAN              
--------------------------------------
 Index Scan using tenk1_four on tenk1
   Scan mode: true
(2 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT ON (four) four, ten
FROM tenk1 WHERE four = 1 ORDER BY four;
                    QUERY PLAN                     
---------------------------------------------------
 Result
   ->  Unique
         ->  Bitmap Heap Scan on tenk1
               Recheck Cond: (four = 1)
               ->  Bitmap Index Scan on tenk1_four
                     Index Cond: (four = 1)
(6 rows)

-- check colums order
SELECT DISTINCT four FROM tenk1 WHERE ten = 2;
 four 
------
    0
    2
(2 rows)

CREATE INDEX tenk1_four_ten on tenk1 (four, ten);
SELECT DISTINCT four FROM tenk1 WHERE ten = 2;
 four 
------
    0
    2
(2 rows)

SELECT DISTINCT on (four, ten) four, ten FROM tenk1 WHERE four = 0;
 four | ten 
------+-----
    0 |   0
    0 |   2
    0 |   4
    0 |   6
    0 |   8
(5 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT four FROM tenk1 WHERE ten = 2;
                  QUERY PLAN                   
-----------------------------------------------
 Index Only Scan using tenk1_four_ten on tenk1
   Scan mode: true
   Index Cond: (ten = 2)
(3 rows)

-- test uniq_distinct_pathkeys
EXPLAIN (COSTS OFF)
SELECT DISTINCT on (four, ten) four, ten FROM tenk1 WHERE four = 0;
                  QUERY PLAN                   
-----------------------------------------------
 Index Only Scan using tenk1_four_ten on tenk1
   Scan mode: true
   Index Cond: (four = 0)
(3 rows)

DROP INDEX tenk1_four_ten;
CREATE INDEX tenk1_ten_four on tenk1 (ten, four);
SELECT DISTINCT four FROM tenk1 WHERE ten = 2;
 four 
------
    0
    2
(2 rows)

SELECT DISTINCT on (four, ten) four, ten FROM tenk1 WHERE ten = 2;
 four | ten 
------+-----
    0 |   2
    2 |   2
(2 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT four FROM tenk1 WHERE ten = 2;
                     QUERY PLAN                      
-----------------------------------------------------
 Unique
   ->  Index Only Scan using tenk1_ten_four on tenk1
         Index Cond: (ten = 2)
(3 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT on (four, ten) four, ten FROM tenk1 WHERE ten = 2;
                     QUERY PLAN                      
-----------------------------------------------------
 Unique
   ->  Index Only Scan using tenk1_ten_four on tenk1
         Index Cond: (ten = 2)
(3 rows)

DROP INDEX tenk1_ten_four;
-- check projection case
SELECT DISTINCT four, four FROM tenk1 WHERE ten = 2;
 four | four 
------+------
    0 |    0
    2 |    2
(2 rows)

SELECT DISTINCT four, 1 FROM tenk1 WHERE ten = 2;
 four | ?column? 
------+----------
    2 |        1
    0 |        1
(2 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT four FROM tenk1;
                QUERY PLAN                 
-------------------------------------------
 Index Only Scan using tenk1_four on tenk1
   Scan mode: true
(2 rows)

-- test cursor forward/backward movements
BEGIN;
DECLARE c SCROLL CURSOR FOR SELECT DISTINCT four FROM tenk1;
FETCH FROM c;
 four 
------
    0
(1 row)

FETCH BACKWARD FROM c;
 four 
------
(0 rows)

FETCH 5 FROM c;
 four 
------
    0
    1
    2
    3
(4 rows)

FETCH BACKWARD 5 FROM c;
 four 
------
    3
    2
    1
    0
(4 rows)

FETCH 5 FROM c;
 four 
------
    0
    1
    2
    3
(4 rows)

FETCH BACKWARD 5 FROM c;
 four 
------
    3
    2
    1
    0
(4 rows)

END;
